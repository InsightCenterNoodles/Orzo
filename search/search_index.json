{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Orzo is the first client application to build on the NOODLES protocol to render 3d scenes in Python. NOODLES allows multiple client applications to interact collaboratively with data in real-time, and now these scenes can be easily displayed in Python. Orzo uses moderngl and Phong shading to bring complex geometry to life.</p>   video"},{"location":"#why-use-orzo","title":"Why use Orzo?","text":"<p>Orzo is a great choice for anyone who wants to easily visualize a NOODLES scene using Python. Whether you are debugging and inspecting state or joining a collaborative session, Orzo offers an accessible entry point for using NOODLES. You can easily inspect the state of the scene and invoke methods from a simple GUI. There is also built in support for moving and manipulating mesh objects in the scene. Entities can be dragged, rotated, and scaled directly or  with configurable widgets. There are also options to change the skybox, default lighting, and shader settings. With Orzo, you can connect to any server that implements the Noodles protocol. If you are looking to use NOODLES with  a different language, there is currently support for C++, Rust,  Julia, and Javascript here. This library is build on top of the  Penne library, and if you are looking to build a server in Python to connect with, check out Rigatoni.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Install the library <pre><code>pip install orzo\n</code></pre></li> <li>Start running and create a window <pre><code>import orzo\n\norzo.run(\"ws://localhost:50000\")\n</code></pre></li> </ol>"},{"location":"basic_usage/","title":"Basic usage","text":"<p>The library abstracts away the details of the NOODLES protocol and provides a simple interface for creating a window  and interacting with a scene. The principal method is <code>run</code>, which starts up the client and displays the server's scene in a new window. This entry point opens with a gui that allows users to connect to any websocket address.</p>"},{"location":"basic_usage/#orzo.run","title":"orzo.run","text":"<pre><code>run()\n</code></pre> <p>Opens Orzo allows user to connect with a GUI</p> Source code in <code>orzo/core.py</code> <pre><code>def run():\n\"\"\"Opens Orzo allows user to connect with a GUI\"\"\"\n    Window.run()\n</code></pre>"},{"location":"basic_usage/#orzo.connect","title":"orzo.connect","text":"<pre><code>connect(address='ws://localhost:50000', default_lighting=True, on_connected=None)\n</code></pre> <p>Connects the Orzo Client to a websocket address</p> <p>Connects to address and opens a window to display the scene. The window will run indefinitely until it is closed. The default lighting parameter is set to True by default to avoid loading an all black scene initially. The default lighting can also be toggled later in the GUI.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Address of the server to connect to</p> <code>'ws://localhost:50000'</code> <code>default_lighting</code> <code>bool</code> <p>Whether to use default lighting</p> <code>True</code> <code>on_connected</code> <code>function</code> <p>Function to run when connected to server</p> <code>None</code> Source code in <code>orzo/core.py</code> <pre><code>def connect(address=\"ws://localhost:50000\", default_lighting=True, on_connected=None):\n\"\"\"Connects the Orzo Client to a websocket address\n\n    Connects to address and opens a window to display the scene. The window will run\n    indefinitely until it is closed. The default lighting parameter is set to True by default to\n    avoid loading an all black scene initially. The default lighting can also be toggled later\n    in the GUI.\n\n    Args:\n        address (str): Address of the server to connect to\n        default_lighting (bool): Whether to use default lighting\n        on_connected (function): Function to run when connected to server\n    \"\"\"\n\n    # Update forward refs where entity -&gt; light -&gt; client -&gt; entity\n    for delegate in delegate_map.values():\n        delegate.update_forward_refs()\n\n    # Create Client and start rendering loop\n    with penne.Client(address, delegate_map, on_connected) as render_client:\n        Window.client = render_client\n        Window.default_lighting = default_lighting\n        Window.run()  # Runs indefinitely until window is closed\n\n    logging.info(f\"Finished Running Orzo Client\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Any help with the project would be super appreciated. Here are some steps to get started.</p> <ol> <li>Clone the repo</li> <li>Install the dependencies    <pre><code>pip install -r requirements.txt\npip install -r tests/requirements.txt\n</code></pre></li> <li>Switch to the <code>develop</code> branch or create a new one</li> <li>Make your changes</li> <li>To update the documentation, simply edit the docstrings for each method.</li> <li>Run the tests<ul> <li>These flags will help show which lines are missing test coverage    <pre><code> pytest --cov orzo --cov-report term-missing\n</code></pre></li> </ul> </li> <li>Submit a pull request<ul> <li>There are github actions set up to run the tests and build the docs for each pull request.</li> </ul> </li> </ol>"},{"location":"install/","title":"Install","text":"<p>Installation is as simple as:</p> <pre><code>pip install orzo\n</code></pre> <p>Orzo has a few dependencies:</p> <ul> <li><code>penne</code>: NOODLES client library</li> <li><code>pyglet</code>: Window backend and event handling for OpenGL</li> <li><code>moderngl</code>: Modern OpenGL wrapper for rendering</li> <li><code>moderngl-window</code>: Windowing and event handling for OpenGL</li> <li><code>imgui</code>: Immediate mode GUI for Python</li> <li><code>numpy</code>: Array manipulation for Python, used in delegates</li> <li><code>numpy-quaternion</code>: Quaternion manipulation for Python, used for entity rotations</li> <li><code>Pillow</code>: Image manipulation for Python, used for texture loading</li> </ul> <p>If you've got Python 3.9+ and <code>pip</code> installed, you're good to go.</p> <p>Note</p> <p>For stability, Rigatoni's core dependencies are pinned to specific versions. While these are up to date as of August 2023, you may want to update them to the latest versions. To do so, simply update the package yourself.</p>"},{"location":"noodles/","title":"What is NOODLES?","text":"<p>NOODLES is a messaging protocol for interactive visualizations. Client and server libraries can implement the protocol to allow for real-time collaboration across visually rich applications.</p> <p>As an intern with little experience in the field of data visualiation and computer graphics, I struggled at first to understand what exactly NOODLES is about and what it aims to accomplish. This document aims to help explain the project to newcomers with all that I have learned while working on Penne, Rigatoni, and Orzo.</p> <p>NOODLES is at its core is a messaging protocol. This is simply an agreement between client and server applications, so  they can communicate in a standardized way. The ultimate goal is to allow for real-time collaboration across different devices or client applications. For example, researchers could all be working on the same data set at the same time  while visualizing it from a web browser, a VR headset, or a command line interface. Researchers no longer would have to set up their data in a specific way to work with a particular visualization tool. Instead, they could use NOODLES to connect their data to any tool that implements the protocol. The NOODLES protocol would be the  bridge between these different tools and devices.</p> <p>While NOODLES specifically refers to the protocol that defines the types of messages that can be sent, this project includes client and server libraries that implement the protocol in a specific language. That way, users can use the  protocol in their language of choice. As of writing this, there is support for python, rust, c++, javascript, and julia.</p>"},{"location":"noodles/#breaking-down-a-noodles-session","title":"Breaking down a NOODLES session","text":"<p>A NOODLES session is composed of a server and one or more clients. A server hosts data and handles requests from clients to manipulate that data. Clients connect to the server with an introductory message and can request data from the server or send messages to the server to invoke methods that manipulate the data. The server then sends updates to all connected clients to keep them in sync.</p>"},{"location":"noodles/#objects-in-a-session","title":"Objects in a Session","text":"<p>If you look at the message specification, you'll notice that the messages follow a pattern. In general, most messages signal the creation, deletion, or modification of an object. These objects include lights, geometries, buffers, and more. These objects are all used to compose a scene that can be  rendered in 3d. Below is a diagram that shows the basic layout of the scene graph.</p> <p></p>"},{"location":"noodles/#methods-and-signals","title":"Methods and Signals","text":"<p>The server defines methods that can be invoked by clients to manipulate the data. For the client this is like getting a menu at a restaurant. If the client invokes a method to say add a point to a data table, the server will process that  message then send a signal to all connected clients to let them know that the data has been updated. The server will also send a reply to let the client know whether the method invocation went through alright.</p>"},{"location":"noodles/#a-spheres-journey","title":"A sphere's journey","text":"<p>To get an idea of how all of these pieces come together to get something 3d to show up on a screen, I figured it would be helpful to walk through an example. Consider the humble sphere...</p> <p></p> <p>First a server application will define some methods that create the sphere, or maybe it will already be present in the server's starting state. This is a problem for the server application which would use the support of a server  library to make this happen. The client connects to the server's websocket address with an intro message, and the server sends back a series of messages to catch the client up to the server's current state. In this example, that would include an entity create message for the general entity that would hold the sphere. Entities are essentially containers that  house lights, geometry, and plots while storing important position information. There would also be a geometry creation message for the sphere geometry / mesh. There would also be buffer create messages for the binary data that makes up this geometry. The buffers could store positions, colors, normals, instances, and more essential information that allow the client to render the sphere. Buffer views let you know how to interpret this binary data. There could possibly be materials and textures messages that would allow the client to render the sphere with unique colors and texture. If there was a texture, you can think of it as a sort of wrapping paper that gets applied to the sphere. An image creation message would be sent to tell the client what this wrapping paper looks like,  and a sampler would let the client know how to apply the wrapping paper to the sphere. </p> <p>With all of these pieces the client has everything it needs to render the sphere, and we have used most objects in the  scene graph diagram above. Most of the work until now has been handled by the server and a client library like Penne, but to render the sphere, Orzo does most of the heavy lifting. The sphere is fundamentally made up of points and triangles that connect those points. To represent this you have a buffer that stores a list of point positions, and a buffer that stores a list of triangles that connect those points. The triangles are represented by a list of indices that point to the points in the position buffer. However, each vertex has more information than just its position. It could have a  normal, a color, or a texture coordinate, and these attributes are also stored as series of bytes. These bytes are  sent to the GPU where shader programs interpret them to render the sphere. The shaders take all of this along with the camera's position and lighting information to compute the color of each pixel on the screen.</p> <p>When thinking about the sphere it is easy to imagine it as a 3d object, but in order to display it to the screen, a series of transformations compute what should be rendered in 2d. The sphere's vertex positions are initially located  in what can be called local space. This means that the vertex positions are all likely centered around the origin, and the sphere needs to be moved to its position in the world. In our context, that shift comes from the entity transforms. Lastly, the scene needs to be aligned with camera and flattened. The shaders generally take care of this work as well, but it can also come up in other areas of the project. For example, at one point I needed to reverse the process to turn a 2d click into a 3d vector. Here is a diagram I found from Anton Gerdelan that  I thought was pretty helpful.</p> <p></p> <p>I don't want to go too far into the details here, but hopefully this gives you a better idea of how all of these pieces come together to render a simple sphere.</p>"},{"location":"noodles/#more-info","title":"More Info","text":"<ul> <li>Full Message Specification</li> <li>More Client and Server Libraries</li> </ul>"}]}